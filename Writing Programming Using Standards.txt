Meaningful names-
------------------------------
The name of a variable, function, or class, should answer all the big questions. It
should tell you why it exists, what it does, and how it is used. If a name requires a com-
ment, then the name does not reveal its intent.
int d; // elapsed time in days.

Use Intention-Revealing Names
-----------------------------------

Avoid Disinformation
----------------------

Make Meaningful Distinctions
-------------------------

Use Pronounceable Names
-------------------------

Use Searchable Names
--------------------------

Avoid Encodings
-----------------------

Member Preﬁxes
------------------------

Avoid Mental Mapping
--------------------------------

A class name should not be a verb.
----------------------------------

Don’t Be Cute-Don't use
--------------------------

Pick One Word per Concept
Pick one word for one abstract concept and stick with it. For instance, it’s confusing to
have fetch, retrieve, and get as equivalent methods of different classes.
----------------------------------------

Don’t Pun
it might seem consistent because we have so many other add methods,
but in this case, the semantics are different, so we should use a name like insert or append
instead. To call the new method add would be a pun.
------------------------------------
Use Solution Domain Names
The name AccountVisitor means a great deal to a programmer who is familiar with
the VISITOR pattern. What programmer would not know what a JobQueue was? There are
lots of very technical things that programmers have to do. Choosing technical names for
those things is usually the most appropriate course.
--------------------------------

Add Meaningful Context
-----------------------------------------

Shorter names are generally better than longer ones, so long as they are clear. Add no
more context to a name than is necessary

========================================================
Functions
So, another way to know that a function is doing more than “one thing” is if you can
extract another function from it with a name that is not merely a restatement of its imple-
mentation [G34].
FUNCTIONS SHOULD DO ONE THING. THEY SHOULD DO IT WELL.
THEY SHOULD DO IT ONLY.

It turns out to be very difﬁcult for programmers to learn to follow this rule and write
functions that stay at a single level of abstraction. But learning this trick is also very
important. It is the key to keeping functions short and making sure they do “one thing.”
Making the code read like a top-down set of TO paragraphs is an effective technique for
keeping the abstraction level consistent.
Take a look at Listing 3-7 at the end of this chapter. It shows the whole
testableHtml function refactored according to the principles described here. Notice
how each function introduces the next, and each function remains at a consistent level
of abstraction.
Remember Ward’s principle: “You know you are working on clean code
when each routine turns out to be pretty much what you expected.” Half the battle to
achieving that principle is choosing good names for small functions that do one thing.
The smaller and more focused a function is, the easier it is to choose a descriptive
name.
Don’t be afraid to make a name long. A long descriptive name is better than a short
enigmatic name. A long descriptive name is better than a long descriptive comment. Use
a naming convention that allows multiple words to be easily read in the function names,
and then make use of those multiple words to give the function a name that says what
it does.

Argumeents
----------------------------
Arguments are even harder from a testing point of view. Imagine the difﬁculty of
writing all the test cases to ensure that all the various combinations of arguments work
properly. If there are no arguments, this is trivial. If there’s one argument, it’s not too hard.
With two arguments the problem gets a bit more challenging. With more than two argu-
ments, testing every combination of appropriate values can be daunting.

Tne input argument is the next best thing to no arguments. SetupTeardown-
Includer.render(pageData) is pretty easy to understand. Clearly we are going to render the
data in the pageData object.

Flag arguments are ugly. Passing a boolean into a function is a truly terrible practice. It
immediately complicates the signature of the method, loudly proclaiming that this function
does more than one thing. It does one thing if the ﬂag is true and another if the ﬂag is false!
-------
A function with two arguments is harder to understand than a monadic function. For exam-
ple, writeField(name) is easier to understand than writeField(output-Stream, name).10
Though the meaning of both is clear, the ﬁrst glides past the eye, easily depositing its
meaning. The second requires a short pause until we learn to ignore the ﬁrst parameter.
And that, of course, eventually results in problems because we should never ignore any
part of code. The parts we ignore are where the bugs will hide.
There are times, of course, where two arguments are appropriate. For example,
Point p = new Point(0,0); is perfectly reasonable. Cartesian points naturally take two
arguments. Indeed, we’d be very surprised to see new Point(0). However, the two argu-
ments in this case are ordered components of a single value! Whereas output-Stream and
name have neither a natural cohesion, nor a natural ordering.

So all the same rules apply. Functions that take variable arguments can be monads,
dyads, or even triads. But it would be a mistake to give them more arguments than
that.
void monad(Integer... args);
void dyad(String name, Integer... args);
void triad(String name, int count, Integer... args);

function and argument should form a very nice verb/noun pair. For example,
write(name) is very evocative. Whatever this “name” thing is, it is being “written.” An
even better name might be writeField(name), which tells us that the “name” thing is a
“ﬁeld

Functions should either do something or answer something, but not both. Either your
function should change the state of an object, or it should return some information about
that object.

Prefer Exceptions to Returning Error Codes
-------------------------------------------------
Returning error codes from command functions is a subtle violation of command query
separation.
------------------------------
Error Handling Is One Thing
Functions should do one thing. Error handing is one thing. Thus, a function that handles
errors should do nothing else. This implies (as in the example above) that if the keyword
try exists in a function, it should be the very ﬁrst word in the function and that there
should be nothing after the catch/finally blocks.

Don’t Repeat Yourself
============================================
Comments:
The proper use of comments is to compensate for our failure to express ourself in
code. Note that I used the word failure. I meant it. Comments are always failures. We must
have them because we cannot always ﬁgure out how to express ourselves without them,
but their use is not a cause for celebration.
---------------------------
Comments Do Not Make Up for Bad Code
One of the more common motivations for writing comments is bad code. We write a mod-
ule and we know it is confusing and disorganized. We know it’s a mess. So we say to our-
selves, “Ooh, I’d better comment that!” No! You’d better clean it!
Clear and expressive code with few comments is far superior to cluttered and complex
code with lots of comments. Rather than spend your time writing the comments that
explain the mess you’ve made, spend it cleaning that mess.
----------------------------------------------
Explain your self in code

// Check to see if the employee is eligible for full benefits
if ((employee.flags & HOURLY_FLAG) &&
(employee.age > 65))
Or this?
if (employee.isEligibleForFullBenefits())
----------------------------------
Good Comments
Some comments are necessary or beneﬁcial. We’ll look at a few that I consider worthy of
the bits they consume. Keep in mind, however, that the only truly good comment is the
comment you found a way not to write.

legal comment
Informative comment
// Returns an instance of the Responder being tested.
protected abstract Responder responderInstance();
A comment like this can sometimes be useful, but it is better to use the name of the func-
tion to convey the information where possible. For example, in this case the comment
could be made redundant by renaming the function: responderBeingTested.
------------------------------------
Explanation of Intent
Sometimes a comment goes beyond just useful information about the implementation and
provides the intent behind a decision

assertTrue(ab.compareTo(aa) == 1); // ab > aa
assertTrue(bb.compareTo(ba) == 1); // bb > ba

There is a substantial risk, of course, that a clarifying comment is incorrect. Go
through the previous example and see how difﬁcult it is to verify that they are correct. This
explains both why the clariﬁcation is necessary and why it’s risky. So before writing com-
ments like this, take care that there is no better way, and then take even more care that they
are accurate.

-------------------
TODO comment
he TODO comment explains why the function has a degenerate implementa-
tion and what that function’s future should be.
//TODO-MdM these are not needed
// We expect this to go away when we do the checkout model
protected VersionInfo makeVersion() throws Exception
{
return null;
}
-------------------------------
Ampliﬁcation
A comment may be used to amplify the importance of something that may otherwise seem
inconsequential.
String listItemContent = match.group(3).trim();
// the trim is real important. It removes the starting
// spaces that could cause the item to be recognized
// as another list.
new ListItemWidget(this, listItemContent, this.level + 1);
return buildList(text.substring(match.end()));

--------------------
Misleading comments
Don’t Use a Comment When You Can Use a Function or a Variable
-----------------------------------------------
There was a time, back in the sixties, when commenting-out code might have been
useful. But we’ve had good source code control systems for a very long time now. Those
systems will remember the code for us. We don’t have to comment it out any more. Just
delete the code. We won’t lose it. Promise.
---------------------------------------------------------
Nonlocal Information
If you must write a comment, then make sure it describes the code it appears near. Don’t
offer systemwide information in the context of a local comment. Consider, for example,
the javadoc comment below.

The purpose of a comment is to explain code that does not explain itself. It is a pity
when a comment needs its own explanation.

================================================
Formating-like a newspaper.

Law of demeter.

Separation of concern

key OO class design principle known as the Open-Closed Principle, or
OCP:4 Classes should be open for extension but closed for modiﬁcation. Our restructured
Sql class is open to allow new functionality via subclassing, but we can make this change
while keeping every other class closed. We simply drop our UpdateSql class in place.
We want to structure our systems so that we muck with as little as possible when we
update them with new or changed features. In an ideal system, we incorporate new fea-
tures by extending the system, not by making modiﬁcations to existing code.
--------------------------
Cohesive
Classes should have a small number of instance variables. Each of the methods of a class
should manipulate one or more of those variables. In general the more variables a method
manipulates the more cohesive that method is to its class. A class in which each variable is
used by each method is maximally cohesive.
In general it is neither advisable nor possible to create such maximally cohesive
classes; on the other hand, we would like cohesion to be high. When cohesion is high, it
means that the methods and variables of the class are co-dependent and hang together as a
logical whole.

-----------------------
The Single Responsibility Principle (SRP)2 states that a class or module should have one,
and only one, reason to change. This principle gives us both a deﬁnition of responsibility,
and a guidelines for class size. Classes should have one responsibility—one reason to
change.

nciple. We regularly encounter classes that do far too many things. Why?
Getting software to work and making software clean are two very different activities.
Most of us have limited room in our heads, so we focus on getting our code to work more
than organization and cleanliness. This is wholly appropriate. Maintaining a separation of
concerns is just as important in our programming activities as it is in our programs.
The problem is that too many of us think that we are done once the program works.
We fail to switch to the other concern of organization and cleanliness. We move on to the
next problem rather than going back and breaking the overstuffed classes into decoupled
units with single responsibilities.
-----------------------------------
Organizing for Change
For most systems, change is continual. Every change subjects us to the risk that the
remainder of the system no longer works as intended. In a clean system we organize our
classes so as to reduce the risk of change.


By minimizing coupling, our classes adhere to another class design princi-
ple known as the Dependency Inversion Principle (DIP).5 In essence, the DIP says that our
classes should depend upon abstractions, not on concrete details.
Instead of being dependent upon the implementation details of the TokyoStock-
Exchange class, our Portfolio class is now dependent upon the StockExchange interface.
The StockExchange interface represents the abstract concept of asking for the current price
of a symbol. This abstraction isolates all of the speciﬁc details of obtaining such a price,
including from where that price is obtained

------------------------------
A powerful mechanism for separating construction from use is Dependency Injection (DI),
the application of Inversion of Control (IoC) to dependency management.3 Inversion of
Control moves secondary responsibilities from an object to other objects that are dedicated
to the purpose, thereby supporting the Single Responsibility Principle. In the context of
dependency management, an object should not take responsibility for instantiating depen-
dencies itself. Instead, it should pass this responsibility to another “authoritative” mecha-
nism, thereby inverting the control. Because setup is a global concern, this authoritative
mechanism will usually be either the “main” routine or a special-purpose container.

Software systems are unique compared to physical systems. Their architectures can grow
incrementally, if we maintain the proper separation of concerns

You incorporate the required application infrastructure, including cross-cutting con-
cerns like persistence, transactions, security, caching, failover, and so on,


An optimal system architecture consists of modularized domains of concern, each of which
is implemented with Plain Old Java (or other) Objects. The different domains are inte-
grated together with minimally invasive Aspects or Aspect-like tools. This architecture can
be test-driven, just like the code.

The agility provided by a POJO system with modularized concerns allows us to make opti-
mal, just-in-time decisions, based on the most recent knowledge. The complexity of these
decisions is also reduced.

Standards make it easier to reuse ideas and components, recruit people with relevant expe-
rience, encapsulate good ideas, and wire components together. However, the process of
creating standards can sometimes take too long for industry to wait, and some standards
lose touch with the real needs of the adopters they are intended to serve

Domain-Speciﬁc Languages allow all levels of abstraction and all domains in the applica-
tion to be expressed as POJOs, from high-level policy to low-level details.

Recommendation: Keep your synchronized sections as small as possible.

Recommendation: Write tests that have the potential to expose problems and then
run them frequently, with different programatic conﬁgurations and system conﬁgurations
and load. If tests ever fail, track down the failure. Don’t ignore a failure just because the
tests pass on a subsequent run.



